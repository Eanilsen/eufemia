/**
 * Prepublish Task
 *
 */

import fs from 'fs-extra'
import path from 'path'
// import del from 'del'
import gulp from 'gulp'
// import file from 'gulp-file' // before we used to pipe only one file though gulp
import rename from 'gulp-rename'
import transform from 'gulp-transform'
import svgr from '@svgr/core'
import prettier from 'prettier'
import camelCase from 'camelcase'
import globby from 'globby'
import { iconCase } from '../../../src/components/icon'
import { log } from '../../lib'
import { readLockFile as readSvgLockFile } from '../../figma/tasks/iconsConverter'

export default ({
  srcPath = ['./assets/icons/*.svg'],
  destPath = './src/icons'
} = {}) =>
  new Promise(async (resolve, reject) => {
    log.start('> PrePublish: converting svg to jsx')
    try {
      // if (!preventDelete) {
      //   await del([`${destPath}/**/*`, `!${destPath}`], {
      //     force: true
      //   })
      // }

      // make sure transformSvgToReact runs first, so icons gets filled before we run makeIconsEntryFiles
      await transformSvgToReact({ srcPath, destPath })
      await makeIconsEntryFiles({
        srcPath: srcPath.concat(['!**/**_big.svg']),
        // srcPath
        destPath
      })
      log.succeed(
        '> PrePublish: "convertSvgToJsx" Converting svg to jsx is done'
      )
    } catch (e) {
      log.fail(e)
      reject(e)
    }
    resolve()
  })

const transformSvgToReact = ({ srcPath, destPath }) => {
  const iconsWeCollectToReturn = []
  return new Promise((resolve, reject) => {
    try {
      gulp
        .src(srcPath, { cwd: process.env.ROOT_DIR })
        .pipe(transform('utf8', transformToJsx))
        .pipe(
          rename({
            extname: '.js'
          })
        )
        .pipe(gulp.dest(destPath, { cwd: process.env.ROOT_DIR }))
        .on('end', () => resolve(iconsWeCollectToReturn))
        .on('error', reject)
    } catch (e) {
      reject(e)
    }
  })
}

const transformToJsx = (content, file) => {
  try {
    const basename = path.basename(file.path)
    const filename = basename.replace(path.extname(file.path), '')
    // const name = iconCase(filename)
    const componentName = camelCase(filename, {
      pascalCase: false
    })
    return new Promise((resolve, reject) =>
      svgr(content, {
        ids: true, //do not remove IDs from the syntax
        prettier: false,
        componentName
      })
        .then(res => {
          resolve(
            '/** This file is auto generated by convertSvgToJsx.js */\n\n' +
              prettier.format(res, {
                ...prettierrc,
                parser: 'babylon'
              })
          )
        })
        .catch(reject)
    )
  } catch (e) {
    console.log('Error in transformToJsx:', e)
    throw e
  }
}

const makeIconsEntryFiles = ({ srcPath, destPath }) =>
  new Promise(async (resolve, reject) => {
    // get all the svg icons we find
    const icons = (await globby(srcPath)).map(file => {
      const basename = path.basename(file)
      const filename = basename.replace(path.extname(file), '')
      const name = iconCase(filename)
      return {
        name,
        filename,
        basename
      }
    })

    // get the svg lock file
    const lockFileContent = await readSvgLockFile()

    // from the svg lock file we can generate groups out of the "frame"
    const groups = Object.entries(lockFileContent).reduce(
      (acc, [file, { frame }]) => {
        acc[frame] = acc[frame] || []
        const basename = path.basename(file)
        const filename = basename.replace(path.extname(file), '')

        // make sure the file actually exists
        if (
          fs.existsSync(
            path.resolve(process.env.ROOT_DIR, destPath, `${filename}.js`)
          )
        ) {
          acc[frame].push({
            filename,
            basename,
            name: iconCase(filename)
          })
        }

        return acc
      },
      {}
    )

    // found on disk as svg files, but was not in the lock file
    const notFoundInLockFile = icons.reduce((acc, cur) => {
      if (!lockFileContent[cur.basename]) {
        acc.push(cur)
      }
      return acc
    }, [])

    if (notFoundInLockFile && notFoundInLockFile.length > 0) {
      log.info(
        `> PrePublish: Files where not found in the .lock file: ${notFoundInLockFile
          .map(({ basename }) => basename)
          .join(', ')}`
      )
    }

    const _imports = icons
      .map(
        ({ name, filename }) => `import ${name} from './${filename}.js'`
      )
      .join('\n')
    const _keys = icons.map(({ name }) => name).join(', ')

    const indexContent = prettier.format(
      `/** This file is auto generated by convertSvgToJsx.js */
        ${_imports}
        export { ${_keys} }
  `,
      {
        ...prettierrc,
        parser: 'babylon'
      }
    )

    try {
      const indexFile = path.resolve(
        process.env.ROOT_DIR,
        destPath,
        `index.js`
      )
      await fs.writeFile(indexFile, indexContent)

      await asyncForEach(
        Object.entries(groups),
        async ([groupName, entries]) => {
          const groupFile = path.resolve(
            process.env.ROOT_DIR,
            destPath,
            `${groupName}.js`
          )

          const _imports = entries
            .map(
              ({ name, filename }) =>
                `import ${name} from './${filename}.js'`
            )
            .join('\n')
          const _keys = entries.map(({ name }) => name).join(', ')

          const groupFileContent = prettier.format(
            `/** This file is auto generated by convertSvgToJsx.js */
            ${_imports}
            export default { ${_keys} }
          `,
            {
              ...prettierrc,
              parser: 'babylon'
            }
          )

          await fs.writeFile(groupFile, groupFileContent)
        }
      )
    } catch (e) {
      reject(e)
    }

    resolve()
  })

const asyncForEach = async (array, callback) => {
  const res = []
  for (let i = 0, l = array.length; i < l; ++i) {
    res.push(await callback(array[i], i, array))
  }
  return res.filter(i => i)
}

const prettierrc = JSON.parse(
  fs.readFileSync(path.resolve(__dirname, '../../../.prettierrc'), 'utf-8')
)
